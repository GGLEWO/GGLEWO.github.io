{"meta":{"title":"GuanYM","subtitle":"热爱生活，向往远方","description":"前端开发一枚，不想秃头的麻鸡。","author":"GuanYm","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-07-08T15:23:22.000Z","updated":"2020-07-08T15:25:04.026Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-06-13T04:12:34.000Z","updated":"2020-07-08T15:25:15.694Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-13T04:12:10.000Z","updated":"2020-06-13T08:11:07.427Z","comments":true,"path":"tags/index-1.html","permalink":"http://yoursite.com/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-10T15:08:47.000Z","updated":"2020-06-10T15:10:12.563Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"React 和 Vue 的20个区别","slug":"React 和 Vue 的20个区别","date":"2020-07-20T03:08:32.000Z","updated":"2020-07-20T03:10:18.439Z","comments":true,"path":"2020/07/20/React 和 Vue 的20个区别/","link":"","permalink":"http://yoursite.com/2020/07/20/React%20%E5%92%8C%20Vue%20%E7%9A%8420%E4%B8%AA%E5%8C%BA%E5%88%AB/","excerpt":"转载前言面试竞争力越来越大，是时候撸一波Vue和React源码啦；本文从20个层面来对比Vue和React的源码区别；如果需要了解API的区别，请戳：Vue 开发必须知道的 36 个技巧React 开发必须知道的 34 个技巧","text":"转载前言面试竞争力越来越大，是时候撸一波Vue和React源码啦；本文从20个层面来对比Vue和React的源码区别；如果需要了解API的区别，请戳：Vue 开发必须知道的 36 个技巧React 开发必须知道的 34 个技巧 1.Vue和React源码区别1.1 Vue源码1.1.1 挂载初始化$mounted会挂载组件,不存在 render 函数时需要编译(compile); 1.1.2 compile1.compile 分为 parse，optimize 和 generate，最终得到 render 函数； 2.parse 调用 parseHtml 方法，方法核心是利用正则解析 template 的指令，class 和 stype，得到 AST； 3.optimize 作用标记 static 静态节点，后面 patch,diff会跳过静态节点； 4.generate 是将 AST 转化为 render 函数表达式，执行 vm._render 方法将 render 表达式转化为VNode，得到 render 和 staticRenderFns 字符串； 5.vm._render 方法调用了 VNode 创建的方法createElement 1234567891011121314151617&#x2F;&#x2F; render函数表达式(function() &#123; with(this)&#123; return _c(&#39;div&#39;,&#123; &#x2F;&#x2F;创建一个 div 元素 attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125; &#x2F;&#x2F;div 添加属性 id &#125;,[ _m(0), &#x2F;&#x2F;静态节点 header，此处对应 staticRenderFns 数组索引为 0 的 render function _v(&quot; &quot;), &#x2F;&#x2F;空的文本节点 (message) &#x2F;&#x2F;判断 message 是否存在 &#x2F;&#x2F;如果存在，创建 p 元素，元素里面有文本，值为 toString(message) ?_c(&#39;p&#39;,[_v(&quot;\\n &quot;+_s(message)+&quot;\\n &quot;)]) &#x2F;&#x2F;如果不存在，创建 p 元素，元素里面有文本，值为 No message. :_c(&#39;p&#39;,[_v(&quot;\\n No message.\\n &quot;)]) ] ) &#125;&#125;) 1.1.3 依赖收集与监听这部分是数据响应式系统1.调用 observer()，作用是遍历对象属性进行双向绑定； 2.在 observer 过程中会注册Object.defineProperty的 get 方法进行依赖收集，依赖收集是将Watcher 对象的实例放入 Dep 中； 3.Object.defineProperty的 set 会调用Dep 对象的 notify 方法通知它内部所有的 Watcher 对象调用对应的 update()进行视图更新； 4.本质是发布者订阅模式的应用 1.1.4 diff 和 patchdiff 算法对比差异和调用 update更新视图：1.patch 的 differ 是将同层的树节点进行比较,通过唯一的 key 进行区分，时间复杂度只有 O(n)； 2.上面将到 set 被触发会调用 watcher 的 update()修改视图； 3.update 方法里面调用 patch()得到同级的 VNode 变化; 4.update 方法里面调用createElm通过虚拟节点创建真实的 DOM 并插入到它的父节点中； 5.createElm实质是遍历虚拟 dom，逆向解析成真实 dom； 1.2 React 源码1.2.1 React.Component1.原型上挂载了setState和forceUpdate方法;2.提供props,context,refs 等属性;3.组件定义通过 extends 关键字继承 Component; 1.2.2 挂载1.render 方法调用了React.createElement方法(实际是ReactElement方法)； 2.ReactDOM.render(component，mountNode)的形式对自定义组件/原生DOM/字符串进行挂载； 3.调用了内部的ReactMount.render，进而执行ReactMount._renderSubtreeIntoContainer,就是将子DOM插入容器； 4.ReactDOM.render()根据传入不同参数会创建四大类组件，返回一个 VNode； 5.四大类组件封装的过程中，调用了mountComponet方法，触发生命周期，解析出 HTML； 1.2.3 组件类型和生命周期1.ReactEmptyComponent,ReactTextComponent,ReactDOMComponent组件没有触发生命周期;2.ReactCompositeComponent类型调用mountComponent方法,会触发生命周期,处理 state 执行componentWillMount钩子,执行 render,获得 html,执行componentDidMounted 1.2.4 data 更新 setState细节请见 3.1 1.2.5 数据绑定1.setState 更新 data 后,shouldComponentUpdate为 true会生成 VNode,为 false 会结束;2.VNode会调用 DOM diff,为 true 更新组件; 1.3 对比React:1.单向数据流;2.setSate 更新data 值后，组件自己处理;3.differ 是首位是除删除外是固定不动的,然后依次遍历对比; Vue:1.v-model 可以实现双向数据流,但只是v-bind:value 和 v-on:input的语法糖;2.通过 this 改变值，会触发 Object.defineProperty的 set，将依赖放入队列，下一个事件循环开始时执行更新时才会进行必要的DOM更新，是外部监听处理更新；3.differcompile 阶段的optimize标记了static 点，可以减少 differ 次数，而且是采用双向遍历方法； 2.React 和 Vue 渲染过程区别2.1 React1.生成期(挂载):参照 1.2.12.更新: 参照1.1.3和 1.1.43.卸载:销毁挂载的组件 2.2 Vue1.new Vue()初始化后initLifecycle(vm),initEvents(vm),initRender(vm),callHook(vm,beforeCreate),initState(vm),callHook(vm,created); 12345A.initLifecycle, 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。如：children、refs、_isMounted等; B.initEvents，用来存放除@hook:生命周期钩子名称&#x3D;&quot;绑定的函数&quot;事件的对象。如：$on、$emit等; C.initRender，用于初始化$slots、$attrs、$listeners; D.initState，是很多选项初始化的汇总，包括：props、methods、data、computed 和 watch 等; E.callHook(vm,created)后才挂载实例 2.compileToFunction:就是将 template 编译成 render 函数;3.watcher: 就是执行1.2.3;4.patch:就是执行 1.2.4 3.AST 和 VNode 的异同1.都是 JSON 对象； 2.AST 是HTML,JS,Java或其他语言的语法的映射对象，VNode 只是 DOM 的映射对象，AST 范围更广； 3.AST的每层的element，包含自身节点的信息(tag,attr等)，同时parent，children分别指向其父element和子element，层层嵌套，形成一棵树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id&#x3D;&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;item in items&quot;&gt; itemid:&#123;&#123;item.id&#125;&#125; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&#x2F;&#x2F;转化为 AST 格式为&#123; &quot;type&quot;: 1, &quot;tag&quot;: &quot;div&quot;, &quot;attrsList&quot;: [ &#123; &quot;name&quot;: &quot;id&quot;, &quot;value&quot;: &quot;app&quot; &#125; ], &quot;attrsMap&quot;: &#123; &quot;id&quot;: &quot;app&quot; &#125;, &quot;children&quot;: [ &#123; &quot;type&quot;: 1, &quot;tag&quot;: &quot;ul&quot;, &quot;attrsList&quot;: [], &quot;attrsMap&quot;: &#123;&#125;, &quot;parent&quot;: &#123; &quot;$ref&quot;: &quot;$&quot; &#125;, &quot;children&quot;: [ &#123; &quot;type&quot;: 1, &quot;tag&quot;: &quot;li&quot;, &#x2F;&#x2F; children省略了很多属性,表示格式即可 &#125; ], &quot;plain&quot;: true &#125; ], &quot;plain&quot;: false, &quot;attrs&quot;: [ &#123; &quot;name&quot;: &quot;id&quot;, &quot;value&quot;: &quot;\\&quot;app\\&quot;&quot; &#125; ]&#125; 4.vnode就是一系列关键属性如标签名、数据、子节点的集合，可以认为是简化了的dom: 12345678910&#123; tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; ...&#125; 5.VNode 的基本分类:EmptyVNode,TextVNode,ComponentVNNode,ElementVNNode,CloneVNode 6.创建 VNode 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859方法一:&#x2F;&#x2F; 利用createDocumentFragment()创建虚拟 dom 片段&#x2F;&#x2F; 节点对象包含dom所有属性和方法&#x2F;&#x2F; html&lt;ul id&#x3D;&quot;ul&quot;&gt;&lt;&#x2F;ul&gt;&#x2F;&#x2F; jsconst element &#x3D; document.getElementById(&#39;ul&#39;);const fragment &#x3D; document.createDocumentFragment();const browsers &#x3D; [&#39;Firefox&#39;, &#39;Chrome&#39;, &#39;Opera&#39;, &#39;Safari&#39;, &#39;Internet Explorer&#39;];browsers.forEach(function(browser) &#123; const li &#x3D; document.createElement(&#39;li&#39;); li.textContent &#x3D; browser; fragment.appendChild(li); &#x2F;&#x2F; 此处往文档片段插入子节点，不会引起回流 （相当于打包操作）&#125;);console.log(fragment)element.appendChild(fragment); &#x2F;&#x2F; 将打包好的文档片段插入ul节点，只做了一次操作,时间快,性能好方法二:&#x2F;&#x2F; 用 JS 对象来模拟 VNodefunction Element (tagName, props, children) &#123; console.log(&#39;this&#39;,this) this.tagName &#x3D; tagName this.props &#x3D; props this.children &#x3D; children&#125;let ElementO &#x3D;new Element(&#39;ul&#39;, &#123;id: &#39;list&#39;&#125;, [ new Element(&#39;li&#39;, &#123;class: &#39;item&#39;&#125;, [&#39;Item 1&#39;]), new Element(&#39;li&#39;, &#123;class: &#39;item&#39;&#125;, [&#39;Item 2&#39;]), new Element(&#39;li&#39;, &#123;class: &#39;item&#39;&#125;, [&#39;Item 3&#39;])])&#x2F;&#x2F; 利用 render 渲染到页面Element.prototype.render &#x3D; function () &#123; const el &#x3D; document.createElement(this.tagName) &#x2F;&#x2F; 根据tagName构建 const props &#x3D; this.props for (const propName in props) &#123; &#x2F;&#x2F; 设置节点的DOM属性 const propValue &#x3D; props[propName] el.setAttribute(propName, propValue) &#125; const children &#x3D; this.children || [] children.forEach(function (child) &#123; const childEl &#x3D; (child instanceof Element) ? child.render() &#x2F;&#x2F; 如果子节点也是虚拟DOM，递归构建DOM节点 : document.createTextNode(child) &#x2F;&#x2F; 如果字符串，只构建文本节点 el.appendChild(childEl) &#125;) return el&#125;console.log(&#39;ElementO&#39;,ElementO)var ulRoot &#x3D; ElementO.render()console.log(&#39;ulRoot&#39;,ulRoot)document.body.appendChild(ulRoot) 4.React 和Vue 的 differ 算法区4.1 React1.Virtual DOM 中的首个节点不执行移动操作（除非它要被移除），以该节点为原点，其它节点都去寻找自己的新位置; 一句话就是首位是老大,不移动; 2.在 Virtual DOM 的顺序中，每一个节点与前一个节点的先后顺序与在 Real DOM 中的顺序进行比较，如果顺序相同，则不必移动，否则就移动到前一个节点的前面或后面; 3.tree diff:只会同级比较,如果是跨级的移动,会先删除节点 A,再创建对应的 A;将 O(n3) 复杂度的问题转换成 O(n) 复杂度; 4.component diff: 根据batchingStrategy.isBatchingUpdates值是否为 true; 如果true 同一类型组件,按照 tree differ 对比; 如果 false将组件放入 dirtyComponent,下面子节点全部替换,具体逻辑看 3.1 setSate 5.element differ: tree differ 下面有三种节点操作:INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除） 请戳 6.代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384_updateChildren: function(nextNestedChildrenElements, transaction, context) &#123; var prevChildren &#x3D; this._renderedChildren var removedNodes &#x3D; &#123;&#125; var mountImages &#x3D; [] &#x2F;&#x2F; 获取新的子元素数组 var nextChildren &#x3D; this._reconcilerUpdateChildren( prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context ) if (!nextChildren &amp;&amp; !prevChildren) &#123; return &#125; var updates &#x3D; null var name var nextIndex &#x3D; 0 var lastIndex &#x3D; 0 var nextMountIndex &#x3D; 0 var lastPlacedNode &#x3D; null for (name in nextChildren) &#123; if (!nextChildren.hasOwnProperty(name)) &#123; continue &#125; var prevChild &#x3D; prevChildren &amp;&amp; prevChildren[name] var nextChild &#x3D; nextChildren[name] if (prevChild &#x3D;&#x3D;&#x3D; nextChild) &#123; &#x2F;&#x2F; 同一个引用，说明是使用的同一个component,所以我们需要做移动的操作 &#x2F;&#x2F; 移动已有的子节点 &#x2F;&#x2F; NOTICE：这里根据nextIndex, lastIndex决定是否移动 updates &#x3D; enqueue( updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex) ) &#x2F;&#x2F; 更新lastIndex lastIndex &#x3D; Math.max(prevChild._mountIndex, lastIndex) &#x2F;&#x2F; 更新component的.mountIndex属性 prevChild._mountIndex &#x3D; nextIndex &#125; else &#123; if (prevChild) &#123; &#x2F;&#x2F; 更新lastIndex lastIndex &#x3D; Math.max(prevChild._mountIndex, lastIndex) &#125; &#x2F;&#x2F; 添加新的子节点在指定的位置上 updates &#x3D; enqueue( updates, this._mountChildAtIndex( nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context ) ) nextMountIndex++ &#125; &#x2F;&#x2F; 更新nextIndex nextIndex++ lastPlacedNode &#x3D; ReactReconciler.getHostNode(nextChild) &#125; &#x2F;&#x2F; 移除掉不存在的旧子节点，和旧子节点和新子节点不同的旧子节点 for (name in removedNodes) &#123; if (removedNodes.hasOwnProperty(name)) &#123; updates &#x3D; enqueue( updates, this._unmountChild(prevChildren[name], removedNodes[name]) ) &#125; &#125; &#125; 4.2 Vue1.自主研发了一套Virtual DOM，是借鉴开源库snabbdom，snabbdom地址 2.也是同级比较，因为在 compile 阶段的optimize标记了static 点，可以减少 differ 次数； 3.Vue 的这个 DOM Diff 过程就是一个查找排序的过程，遍历 Virtual DOM 的节点，在 Real DOM 中找到对应的节点，并移动到新的位置上。不过这套算法使用了双向遍历的方式，加速了遍历的速度，更多请戳； 4.代码实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869updateChildren (parentElm, oldCh, newCh) &#123; let oldStartIdx &#x3D; 0, newStartIdx &#x3D; 0 let oldEndIdx &#x3D; oldCh.length - 1 let oldStartVnode &#x3D; oldCh[0] let oldEndVnode &#x3D; oldCh[oldEndIdx] let newEndIdx &#x3D; newCh.length - 1 let newStartVnode &#x3D; newCh[0] let newEndVnode &#x3D; newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx &lt;&#x3D; oldEndIdx &amp;&amp; newStartIdx &lt;&#x3D; newEndIdx) &#123; if (oldStartVnode &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;对于vnode.key的比较，会把oldVnode &#x3D; null oldStartVnode &#x3D; oldCh[++oldStartIdx] &#125;else if (oldEndVnode &#x3D;&#x3D; null) &#123; oldEndVnode &#x3D; oldCh[--oldEndIdx] &#125;else if (newStartVnode &#x3D;&#x3D; null) &#123; newStartVnode &#x3D; newCh[++newStartIdx] &#125;else if (newEndVnode &#x3D;&#x3D; null) &#123; newEndVnode &#x3D; newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode) oldStartVnode &#x3D; oldCh[++oldStartIdx] newStartVnode &#x3D; newCh[++newStartIdx] &#125;else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode) oldEndVnode &#x3D; oldCh[--oldEndIdx] newEndVnode &#x3D; newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode &#x3D; oldCh[++oldStartIdx] newEndVnode &#x3D; newCh[--newEndIdx] &#125;else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode &#x3D; oldCh[--oldEndIdx] newStartVnode &#x3D; newCh[++newStartIdx] &#125;else &#123; &#x2F;&#x2F; 使用key时的比较 if (oldKeyToIdx &#x3D;&#x3D;&#x3D; undefined) &#123; oldKeyToIdx &#x3D; createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) &#x2F;&#x2F; 有key生成index表 &#125; idxInOld &#x3D; oldKeyToIdx[newStartVnode.key] if (!idxInOld) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode &#x3D; newCh[++newStartIdx] &#125; else &#123; elmToMove &#x3D; oldCh[idxInOld] if (elmToMove.sel !&#x3D;&#x3D; newStartVnode.sel) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) &#125;else &#123; patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] &#x3D; null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) &#125; newStartVnode &#x3D; newCh[++newStartIdx] &#125; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; before &#x3D; newCh[newEndIdx + 1] &#x3D;&#x3D; null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) &#125;else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 4.3 对比相同点:都是同层 differ,复杂度都为 O(n); 不同点:1.React 首位是除删除外是固定不动的,然后依次遍历对比;2.Vue 的compile 阶段的optimize标记了static 点,可以减少 differ 次数,而且是采用双向遍历方法; 5.React 的 setState和 Vue 改变值的区别5.1 setState1.setState 通过一个队列机制来实现 state 更新，当执行 setState() 时，会将需要更新的 state 浅合并后,根据变量 isBatchingUpdates(默认为 false)判断是直接更新还是放入状态队列； 2.通过js的事件绑定程序 addEventListener 和使用setTimeout/setInterval 等 React 无法掌控的 API情况下isBatchingUpdates 为 false，同步更新。除了这几种情况外batchedUpdates函数将isBatchingUpdates修改为 true； 3.放入队列的不会立即更新 state，队列机制可以高效的批量更新 state。而如果不通过setState，直接修改this.state 的值，则不会放入状态队列; 4.setState 依次直接设置 state 值会被合并，但是传入 function 不会被合并；让setState接受一个函数的API的设计是相当棒的！不仅符合函数式编程的思想，让开发者写出没有副作用的函数，而且我们并不去修改组件状态，只是把要改变的状态和结果返回给React，维护状态的活完全交给React去做。正是把流程的控制权交给了React，所以React才能协调多个setState调用的关系 123456789101112131415161718192021222324252627282930&#x2F;&#x2F; 情况一state&#x3D;&#123; count:0&#125;handleClick() &#123; this.setState(&#123; count: this.state.count + 1 &#125;) this.setState(&#123; count: this.state.count + 1 &#125;) this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&#x2F;&#x2F; count 值依旧为1&#x2F;&#x2F; 情况二increment(state, props) &#123; return &#123; count: state.count + 1 &#125;&#125;handleClick() &#123; this.setState(this.increment) this.setState(this.increment) this.setState(this.increment)&#125;&#x2F;&#x2F; count 值为 3 5.更新后执行四个钩子:shouleComponentUpdate,componentWillUpdate,render,componentDidUpdate 5.2 Vue 的 this 改变1.vue 自身维护 一个 更新队列，当你设置 this.a = ‘new value’，DOM 并不会马上更新； 2.在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更； 3.如果同一个 watcher 被多次触发，只会被推入到队列中一次； 4.也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新和去重； 5.所以 for 循环 10000次 this.a = i vue只会更新一次，而不会更新10000次; 6.data 变化后如果 computed 或 watch 监听则会执行; 6. Vue的v-for 或 React 的map 中为什么不要用 index作为 key6.1 为什么要加 key6.1.1 React1.上面的 5.1 讲到 React 的 differ 中 element differ 有三种节点操作； 2.场景一不加 key: 新老集合进行 diff 差异化对比，发现 B != A，则创建并插入 B 至新集合，删除老集合 A；以此类推，创建并插入 A、D 和 C，删除 B、C 和 D； 都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可； 3.场景二加 key: 新建：从新集合中取得 E，判断老集合中不存在相同节点 E，则创建新节点 ElastIndex不做处理E的位置更新为新集合中的位置，nextIndex++； 删除：当完成新集合中所有节点 diff 时，最后还需要对老集合进行循环遍历，判断是否存在新集合中没有但老集合中仍存在的节点，发现存在这样的节点 D，因此删除节点 D； 4.总结: 显然加了 key 后操作步骤要少很多,性能更好； 但是都会存在一个问题，上面场景二只需要移动首位，位置就可对应，但是由于首位是老大不能动，所以应该尽量减少将最后一个节点移动到首位，更多请戳。 6.1.2 VueVue 不加 key 场景分析:1.场景一不加 key:也会将使用了双向遍历的方式查找,发现 A,B,C,D都不等,先删除再创建； 2.场景二加 key:双向遍历的方式查找只需要创建E，删除D，改变 B、C、A的位置 6.2 为什么 key 不能为 index这个问题分为两个方面:1.如果列表是纯静态展示，不会 CRUD，这样用 index 作为 key 没得啥问题； 2.如果不是 12345const list &#x3D; [1,2,3,4];&#x2F;&#x2F; list 删除 4 不会有问题,但是如果删除了非 4 就会有问题&#x2F;&#x2F; 如果删除 2const listN&#x3D; [1,3,4]&#x2F;&#x2F; 这样index对应的值就变化了,整个 list 会重新渲染 3.所以 list 最好不要用 index 作为 key 7. Redux和 Vuex 设计思想7.1 ReduxAPI:1.Redux则是一个纯粹的状态管理系统，React利用React-Redux将它与React框架结合起来； 2.只有一个用createStore方法创建一个 store； 3.action接收 view 发出的通知，告诉 Store State 要改变，有一个 type 属性； 4.reducer:纯函数来处理事件，纯函数指一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用,得到一个新的 state； 源码组成: 1234561.createStore 创建仓库，接受reducer作为参数 2.bindActionCreator 绑定store.dispatch和action 的关系 3.combineReducers 合并多个reducers 4.applyMiddleware 洋葱模型的中间件,介于dispatch和action之间，重写dispatch5.compose 整合多个中间件6.单一数据流;state 是可读的,必须通过 action 改变;reducer设计成纯函数; 7.2 Vuex1.Vuex是吸收了Redux的经验，放弃了一些特性并做了一些优化，代价就是VUEX只能和VUE配合； 2.store:通过 new Vuex.store创建 store，辅助函数mapState； 3.getters:获取state，有辅助函数 mapGetters； 4.action:异步改变 state，像ajax，辅助函数mapActions； 5.mutation:同步改变 state,辅助函数mapMutations； 7.3 对比1231.Redux： view——&gt;actions——&gt;reducer——&gt;state变化——&gt;view变化（同步异步一样）2.Vuex： view——&gt;commit——&gt;mutations——&gt;state变化——&gt;view变化（同步操作） view——&gt;dispatch——&gt;actions——&gt;mutations——&gt;state变化——&gt;view变化（异步操作） 8.redux 为什么要把 reducer 设计成纯函数1.纯函数概念:一个函数的返回结果只依赖于它的参数(外面的变量不会改变自己)，并且在执行过程里面没有副作用(自己不会改变外面的变量)； 2.主要就是为了减小副作用，避免影响 state 值，造成错误的渲染； 3.把reducer设计成纯函数，便于调试追踪改变记录； 9.Vuex的mutation和Redux的reducer中为什么不能做异步操作1.在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行； 2.vuex 真正限制你的只有 mutation 必须是同步的这一点（在 redux 里面就好像 reducer 必须同步返回下一个状态一样）； 3.每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态； 4.其实就是框架是这么设计的,便于调试追踪改变记录 10.双向绑定和 vuex 是否冲突1.在严格模式中使用Vuex，当用户输入时，v-model会试图直接修改属性值，但这个修改不是在mutation中修改的，所以会抛出一个错误； 2.当需要在组件中使用vuex中的state时，有2种解决方案： 123456789101112131415在input中绑定value(vuex中的state)，然后监听input的change或者input事件，在事件回调中调用mutation修改state的值; &#x2F;&#x2F; 双向绑定计算属性&lt;input v-model&#x3D;&quot;message&quot;&gt;computed: &#123; message: &#123; get () &#123; return this.$store.state.obj.message &#125;, set (value) &#123; this.$store.commit(&#39;updateMessage&#39;, value) &#125; &#125;&#125; 11. Vue的nextTick原理11.1 使用场景什么时候会用到?nextTick的使用原则主要就是解决单一事件更新数据后立即操作dom的场景。 11.2 原理1.vue 用异步队列的方式来控制 DOM 更新和 nextTick 回调先后执行； 2.microtask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕； 3.考虑兼容问题，vue 做了 microtask 向 macrotask 的降级方案； 4.代码实现: 123456789const simpleNextTick &#x3D; function queueNextTick (cb) &#123; return Promise.resolve().then(() &#x3D;&gt; &#123; cb() &#125;)&#125;simpleNextTick(() &#x3D;&gt; &#123; console.log(this.$refs.test.innerText)&#125;) 13. Vue 的data 必须是函数而 React 的 state 是对象13.1 Vue 的 data 必须是函数对象是引用类型，内存是存贮引用地址，那么子组件中的 data 属性值会互相污染，产生副作用；如果是函数，函数的{}构成作用域，每个实例相互独立，不会相互影响； 13.2 React 的 state 是对象因为 state 是定义在函数里面,作用域已经独立 14.Vue 的合并策略1.生命周期钩子:合并为数组 12345678910111213141516function mergeHook ( parentVal, childVal ) &#123; return childVal ? parentVal &#x2F;&#x2F; 如果 childVal存在 ? parentVal.concat(childVal) &#x2F;&#x2F; 如果parentVal存在，直接合并 : Array.isArray(childVal) &#x2F;&#x2F; 如果parentVal不存在 ? childVal &#x2F;&#x2F; 如果chilidVal是数组，直接返回 : [childVal] &#x2F;&#x2F; 包装成一个数组返回 : parentVal &#x2F;&#x2F; 如果childVal 不存在 直接返回parentVal &#125;&#x2F;&#x2F; strats中添加属性，属性名为生命周期各个钩子config._lifecycleHooks.forEach(function (hook) &#123; strats[hook] &#x3D; mergeHook &#x2F;&#x2F; 设置每一个钩子函数的合并策略&#125;) 2.watch：合并为数组，执行有先后顺序； 3.assets（components、filters、directives）：合并为原型链式结构,合并的策略就是返回一个合并后的新对象，新对象的自有属性全部来自 childVal， 但是通过原型链委托在了 parentVal 上 12345678910function mergeAssets (parentVal, childVal) &#123; &#x2F;&#x2F; parentVal: Object childVal: Object var res &#x3D; Object.create(parentVal || null) &#x2F;&#x2F; 原型委托 return childVal ? extend(res, childVal) : res&#125;config._assetTypes.forEach(function (type) &#123; strats[type + &#39;s&#39;] &#x3D; mergeAssets&#125;) 4.data为function，需要合并执行后的结果，就是执行 parentVal 和 childVal 的函数，然后再合并函数返回的对象； 5.自定义合并策略： 123Vue.config.optionMergeStrategies.watch &#x3D; function (toVal, fromVal) &#123; &#x2F;&#x2F; return mergedVal&#125; 14.Vue-router 的路由模式1.三种：”hash” | “history” | “abstract”； 2.hash(默认),history 是浏览器环境，abstract是 node 环境； 3.hash: 使用 URL hash 值来作路由，是利用哈希值实现push、replace、go 等方法； 4.history:依赖 HTML5 History API新增的 pushState() 和 replaceState()，需要服务器配置； 5.abstract:如果发现没有浏览器的 API，路由会自动强制进入这个模式。 15.Vue 的事件机制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Vue &#123; constructor() &#123; &#x2F;&#x2F; 事件通道调度中心 this._events &#x3D; Object.create(null); &#125; $on(event, fn) &#123; if (Array.isArray(event)) &#123; event.map(item &#x3D;&gt; &#123; this.$on(item, fn); &#125;); &#125; else &#123; (this._events[event] || (this._events[event] &#x3D; [])).push(fn); &#125; return this; &#125; $once(event, fn) &#123; function on() &#123; this.$off(event, on); fn.apply(this, arguments); &#125; on.fn &#x3D; fn; this.$on(event, on); return this; &#125; $off(event, fn) &#123; if (!arguments.length) &#123; this._events &#x3D; Object.create(null); return this; &#125; if (Array.isArray(event)) &#123; event.map(item &#x3D;&gt; &#123; this.$off(item, fn); &#125;); return this; &#125; const cbs &#x3D; this._events[event]; if (!cbs) &#123; return this;&#125; if (!fn) &#123; this._events[event] &#x3D; null; return this; &#125; let cb; let i &#x3D; cbs.length; while (i--) &#123; cb &#x3D; cbs[i]; if (cb &#x3D;&#x3D;&#x3D; fn || cb.fn &#x3D;&#x3D;&#x3D; fn) &#123; cbs.splice(i, 1); break; &#125; &#125; return this; &#125; $emit(event) &#123; let cbs &#x3D; this._events[event]; if (cbs) &#123; const args &#x3D; [].slice.call(arguments, 1); cbs.map(item &#x3D;&gt; &#123; args ? item.apply(this, args) : item.call(this); &#125;); &#125; return this; &#125;&#125; 16.keep-alive 的实现原理和缓存策略1.获取keep-alive第一个子组件； 2.根据include exclude名单进行匹配，决定是否缓存。如果不匹配，直接返回组件实例，如果匹配，到第3步； 3.根据组件id和tag生成缓存组件的key，再去判断cache中是否存在这个key，即是否命中缓存，如果命中，用缓存中的实例替代vnode实例，然后更新key在keys中的位置，(LRU置换策略)。如果没有命中，就缓存下来，如果超出缓存最大数量max,删除cache中的第一项。 4.keep-alive是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中； 5.LRU算法:根据数据的历史访问记录来进行淘汰数据，其实就是访问过的，以后访问概率会高； 6.LRU 实现: 新数据插入到链表头部； 每当缓存命中（即缓存数据被访问），则将数据移到链表头部； 当链表满的时候，将链表尾部的数据丢弃。 17.Vue 的 set 原理1.由于 Object.observe()方法废弃了，所以Vue 无法检测到对象属性的添加或删除； 2.原理实现: 判断是否是数组，是利用 splice 处理值； 判断是否是对象的属性，直接赋值； 不是数组，且不是对象属性，创建一个新属性，不是响应数据直接赋值，是响应数据调用defineReactive； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123; &#x2F;&#x2F; 如果 set 函数的第一个参数是 undefined 或 null 或者是原始类型值，那么在非生产环境下会打印警告信息 &#x2F;&#x2F; 这个api本来就是给对象与数组使用的 if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; (isUndef(target) || isPrimitive(target)) ) &#123; warn(&#96;Cannot set reactive property on undefined, null, or primitive value: $&#123;(target: any)&#125;&#96;) &#125; if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; &#x2F;&#x2F; 类似$vm.set(vm.$data.arr, 0, 3) &#x2F;&#x2F; 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误 target.length &#x3D; Math.max(target.length, key) &#x2F;&#x2F; 利用数组的splice变异方法触发响应式, 这个前面讲过 target.splice(key, 1, val) return val &#125; &#x2F;&#x2F; target为对象, key在target或者target.prototype上。 &#x2F;&#x2F; 同时必须不能在 Object.prototype 上 &#x2F;&#x2F; 直接修改即可, 有兴趣可以看issue: https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;vue&#x2F;issues&#x2F;6845 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] &#x3D; val return val &#125; &#x2F;&#x2F; 以上都不成立, 即开始给target创建一个全新的属性 &#x2F;&#x2F; 获取Observer实例 const ob &#x3D; (target: any).__ob__ &#x2F;&#x2F; Vue 实例对象拥有 _isVue 属性, 即不允许给Vue 实例对象添加属性 &#x2F;&#x2F; 也不允许Vue.set&#x2F;$set 函数为根数据对象(vm.$data)添加属性 if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn( &#39;Avoid adding reactive properties to a Vue instance or its root $data &#39; + &#39;at runtime - declare it upfront in the data option.&#39; ) return val &#125; &#x2F;&#x2F; target本身就不是响应式数据, 直接赋值 if (!ob) &#123; target[key] &#x3D; val return val &#125; &#x2F;&#x2F; 进行响应式处理 defineReactive(ob.value, key, val) ob.dep.notify() return val&#125;https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5e04411f6fb9a0166049a073#heading-18 18.简写 Redux1234567891011121314151617181920212223242526272829function createStore(reducer) &#123; let state; let listeners&#x3D;[]; function getState() &#123; return state; &#125; function dispatch(action) &#123; state&#x3D;reducer(state,action); listeners.forEach(l&#x3D;&gt;l()); &#125; function subscribe(listener) &#123; listeners.push(listener); return function () &#123; const index&#x3D;listeners.indexOf(listener); listeners.splice(inddx,1); &#125; &#125; dispatch(&#123;&#125;); return &#123; getState, dispatch, subscribe &#125;&#125; 19 react-redux是如何来实现的源码组成:1.connect 将store和dispatch分别映射成props属性对象，返回组件2.context 上下文 导出Provider,,和 consumer3.Provider 一个接受store的组件，通过context api传递给所有子组件 20. react16 的 fiber 理解1.react 可以分为 differ 阶段和 commit(操作 dom)阶段； 2.v16 之前是向下递归算法，会阻塞； 3.v16 引入了代号为 fiber 的异步渲染架构； 4.fiber 核心实现了一个基于优先级和requestIdleCallback循环任务调度算法； 5.算法可以把任务拆分成小任务，可以随时终止和恢复任务，可以根据优先级不同控制执行顺序，更多请戳； 总结原创码字不易，欢迎star！您的鼓励是我持续创作的动力！","categories":[],"tags":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"js运行机制","slug":"js运行机制梳理","date":"2020-07-19T14:44:20.000Z","updated":"2020-07-19T15:45:32.855Z","comments":true,"path":"2020/07/19/js运行机制梳理/","link":"","permalink":"http://yoursite.com/2020/07/19/js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%A2%B3%E7%90%86/","excerpt":"转载于 https://segmentfault.com/a/1190000012925872 ———-正文开始———- 最近发现有不少介绍JS单线程运行机制的文章，但是发现很多都仅仅是介绍某一部分的知识，而且各个地方的说法还不统一，容易造成困惑。因此准备梳理这块知识点，结合已有的认知，基于网上的大量参考资料，从浏览器多进程到JS单线程，将JS引擎的运行机制系统的梳理一遍。 展现形式：由于是属于系统梳理型，就没有由浅入深了，而是从头到尾的梳理知识体系，重点是将关键节点的知识点串联起来，而不是仅仅剖析某一部分知识。 内容是：从浏览器进程，再到浏览器内核运行，再到JS引擎单线程，再到JS事件循环机制，从头到尾系统的梳理一遍，摆脱碎片化，形成一个知识体系 目标是：看完这篇文章后，对浏览器多进程，JS单线程，JS事件循环机制这些都能有一定理解，有一个知识体系骨架，而不是似懂非懂的感觉。 另外，本文适合有一定经验的前端人员，新手请规避，避免受到过多的概念冲击。可以先存起来，有了一定理解后再看，也可以分成多批次观看，避免过度疲劳。","text":"转载于 https://segmentfault.com/a/1190000012925872 ———-正文开始———- 最近发现有不少介绍JS单线程运行机制的文章，但是发现很多都仅仅是介绍某一部分的知识，而且各个地方的说法还不统一，容易造成困惑。因此准备梳理这块知识点，结合已有的认知，基于网上的大量参考资料，从浏览器多进程到JS单线程，将JS引擎的运行机制系统的梳理一遍。 展现形式：由于是属于系统梳理型，就没有由浅入深了，而是从头到尾的梳理知识体系，重点是将关键节点的知识点串联起来，而不是仅仅剖析某一部分知识。 内容是：从浏览器进程，再到浏览器内核运行，再到JS引擎单线程，再到JS事件循环机制，从头到尾系统的梳理一遍，摆脱碎片化，形成一个知识体系 目标是：看完这篇文章后，对浏览器多进程，JS单线程，JS事件循环机制这些都能有一定理解，有一个知识体系骨架，而不是似懂非懂的感觉。 另外，本文适合有一定经验的前端人员，新手请规避，避免受到过多的概念冲击。可以先存起来，有了一定理解后再看，也可以分成多批次观看，避免过度疲劳。 大纲 区分进程和线程 浏览器是多进程的 浏览器都包含哪些进程？ 浏览器多进程的优势 重点是浏览器内核（渲染进程） Browser进程和浏览器内核（Renderer进程）的通信过程 梳理浏览器内核中线程之间的关系 GUI渲染线程与JS引擎线程互斥 JS阻塞页面加载 WebWorker，JS的多线程？ WebWorker与SharedWorker 简单梳理下浏览器渲染流程 load事件与DOMContentLoaded事件的先后 css加载是否会阻塞dom树渲染？ 普通图层和复合图层 从Event Loop谈JS的运行机制 事件循环机制进一步补充 单独说说定时器 setTimeout而不是setInterval 事件循环进阶：macrotask与microtask 写在最后的话 区分进程和线程线程和进程区分不清，是很多新手都会犯的错误，没有关系。这很正常。先看看下面这个形象的比喻： - 进程是一个工厂，工厂有它的独立资源 - 工厂之间相互独立 - 线程是工厂中的工人，多个工人协作完成任务 - 工厂内有一个或多个工人 - 工人之间共享空间再完善完善概念： - 工厂的资源 -&gt; 系统分配的内存（独立的一块内存） - 工厂之间的相互独立 -&gt; 进程之间相互独立 - 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务 - 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成 - 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）然后再巩固下： 如果是windows电脑中，可以打开任务管理器，可以看到有一个后台进程列表。对，那里就是查看进程的地方，而且可以看到每个进程的内存资源信息以及cpu占有率。 所以，应该更容易理解了：进程是cpu资源分配的最小单位（系统会给它分配内存） 最后，再用较为官方的术语描述一遍： 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位） 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程） tips 不同进程之间也可以通信，不过代价较大 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行） 浏览器是多进程的理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解） 浏览器是多进程的 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存） 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。 关于以上几点的验证，请再第一张图： 图中打开了Chrome浏览器的多个标签页，然后可以在Chrome的任务管理器中看到有多个进程（分别是每一个Tab页面有一个独立的进程，以及一个主进程）。感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会+1以上 注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了（所以每一个Tab标签对应一个进程并不一定是绝对的） 浏览器都包含哪些进程？知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程） Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有 负责浏览器界面显示，与用户交互。如前进，后退等 负责各个页面的管理，创建和销毁其他进程 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上 网络资源的管理，下载等 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU进程：最多一个，用于3D绘制等 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为 页面渲染，脚本执行，事件处理等 强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程） 当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图 另外，可以通过Chrome的更多工具 -&gt; 任务管理器自行验证 浏览器多进程的优势相比于单进程浏览器，多进程有如下优点： 避免单个page crash影响整个浏览器 避免第三方插件crash影响整个浏览器 多进程充分利用多核优势 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性 简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。 当然，内存等资源消耗也会更大，有点空间换时间的意思。 重点是浏览器内核（渲染进程）重点来了，我们可以看到，上面提到了这么多的进程，那么，对于普通的前端操作来说，最终要的是什么呢？答案是渲染进程 可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程 请牢记，浏览器的渲染进程是多线程的（这点如果不理解，请回头看进程和线程的区分） 终于到了线程这个概念了?，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）： GUI渲染线程 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 定时触发器线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 异步http请求线程 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于事件触发线程的，所以如果仅仅是看某个碎片化知识，可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧： 再说一点，为什么JS引擎是单线程的？额，这个问题其实应该没有标准答案，譬如，可能仅仅是因为由于多线程的复杂性，譬如多线程操作一般要加锁，因此最初设计时选择了单线程。。。 Browser进程和浏览器内核（Renderer进程）的通信过程看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。 如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程），然后在这前提下，看下整个的过程：(简化了很多) Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程 Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘） 最后Render进程将结果传递给Browser进程 Browser进程接收到结果并将结果绘制出来 这里绘一张简单的图：（很简化） 看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。 这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。 如果这一块要深挖，建议去读一些浏览器内核源码解析文章，或者可以先看看参考下来源中的第一篇文章，写的不错 梳理浏览器内核中线程之间的关系到了这里，已经对浏览器的运行有了一个整体的概念，接下来，先简单梳理一些概念 GUI渲染线程与JS引擎线程互斥由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。 JS阻塞页面加载从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。 譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。 所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 WebWorker，JS的多线程？前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？ 所以，后来HTML5中支持了Web Worker。 MDN的官方解释是： Web Worker 为 Web 内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面 一个 worker 是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的 JavaScript 文件 这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window 因此，使用 window快捷方式获取当前全局的范围 (而不是 self) 在一个 Worker 内将返回错误这样理解下： 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM） JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据） 所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，只待计算出结果后，将结果通信给主线程即可，perfect! 而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。 其它，关于Worker的详解就不是本文的范畴了，因此不再赘述。 WebWorker与SharedWorker既然都到了这里，就再提一下SharedWorker（避免后续将这两个概念搞混） WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。 SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。 看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程 简单梳理下浏览器渲染流程本来是直接计划开始谈JS运行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到JS可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本） 为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文） - 浏览器输入 url，浏览器主进程接管，开一个下载线程， 然后进行 http 请求（略去 DNS 查询，IP 寻址等等操作），然后等待响应，获取内容， 随后将内容通过 RendererHost 接口转交给 Renderer 进程 - 浏览器渲染流程开始浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤： 解析html建立dom树 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树） 布局render树（Layout/reflow），负责各元素尺寸、位置的计算 绘制render树（paint），绘制页面像素信息 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。 所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了 既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。 这里重绘参考来源中的一张图：（参考来源第一篇） load事件与DOMContentLoaded事件的先后上面提到，渲染完毕后会触发load事件，那么你能分清楚load事件与DOMContentLoaded事件的先后么？ 很简单，知道它们的定义就可以了： 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成) 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了） 所以，顺序是：DOMContentLoaded -&gt; load css加载是否会阻塞dom树渲染？这里说的是头部引入css的情况 首先，我们都知道：css是由单独的下载线程异步下载的。 然后再说下几个现象： css加载不会阻塞DOM树解析（异步加载时DOM照常构建） 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息） 这可能也是浏览器的一种优化机制。 因为你加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞render树渲染的话，那么当css加载完之后，render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。 普通图层和复合图层渲染步骤中就提到了composite概念。 可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层以及复合图层 首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中） 其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。 然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘） 可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒 可以Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders中看到，黄色的就是复合图层信息 如下图。可以验证上述的说法 如何变成复合图层（硬件加速） 将该元素变成一个复合图层，就是传说中的硬件加速技术 最常用的方式：translate3d、translateZ opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态） will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）， 作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放） &lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;等元素 其它，譬如以前的flash插件 absolute和硬件加速的区别 可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的） 而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图） 复合图层的作用？ 一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能 但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡 硬件加速时请使用index 使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染 具体的原理时这样的：webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能 简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意 另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）： http://web.jobbole.com/83575/ 从Event Loop谈JS的运行机制到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。 注意，这里不谈可执行上下文，VO，scop chain等概念（这些完全可以整理成另一篇文章了），这里主要是结合Event Loop来谈JS代码是如何执行的。 读这部分的前提是已经知道了JS引擎是单线程，而且这里会用到上文中的几个概念：（如果不是很理解，可以回头温习） JS引擎线程 事件触发线程 定时触发器线程 然后再理解一个概念： JS分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 看图： 看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，所以自然有误差。 事件循环机制进一步补充这里就直接引用一张图片来协助理解：（参考自Philip Roberts的演讲《Help, I’m stuck in an event-loop》） 上图大致描述就是： 主线程运行时会产生执行栈， 栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕） 而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调 如此循环 注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件 单独说说定时器上述事件循环机制的核心是：JS引擎线程和事件触发线程 但事件上，里面还有一些隐藏细节，譬如调用setTimeout后，是如何等待特定时间后才添加到事件队列中的？ 是JS引擎检测的么？当然不是了。它是由定时器线程控制（因为JS引擎自己都忙不过来，根本无暇分身） 为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。 什么时候会用到定时器线程？当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。 譬如: setTimeout(function(){ console.log(&apos;hello!&apos;); }, 1000);这段代码的作用是当1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行 setTimeout(function(){ console.log(&apos;hello!&apos;); }, 0); console.log(&apos;begin&apos;);这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行 注意： 执行结果是：先begin后hello! 虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 (不过也有一说是不同浏览器有不同的最小时间设定) 就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有可执行栈内空了后才会主动读取事件队列） setTimeout而不是setInterval用setTimeout模拟定期计时和直接用setInterval是有区别的。 因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差（误差多少与代码执行时间有关） 而setInterval则是每次都精确的隔一段时间推入一个事件（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了） 而且setInterval有一些比较致命的问题就是： 累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行， 就会导致定时器代码连续运行好几次，而之间没有间隔。就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间） 譬如像iOS的webview,或者Safari等浏览器中都有一个特点，在滚动的时候是不执行JS的，如果使用了setInterval，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调，如果回调执行时间过长,就会非常容器造成卡顿问题和一些不可知的错误（这一块后续有补充，setInterval自带的优化，不会重复添加回调）* 而且把浏览器最小化显示等操作时，setInterval并不是不执行程序， 它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时 所以，鉴于这么多但问题，目前一般认为的最佳方案是：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame 补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。 事件循环进阶：macrotask与microtask这段参考了参考来源中的第2篇文章（英文版的），（加了下自己的理解重新描述了下），强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下： https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/ 上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题： console.log(&apos;script start&apos;); setTimeout(function() { console.log(&apos;setTimeout&apos;); }, 0); Promise.resolve().then(function() { console.log(&apos;promise1&apos;); }).then(function() { console.log(&apos;promise2&apos;); }); console.log(&apos;script end&apos;);嗯哼，它的正确执行顺序是这样子的： script start script end promise1 promise2 setTimeout为什么呢？因为Promise里有了一个一个新的概念：microtask 或者，进一步，JS中分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task 它们的定义？区别？简单点可以按如下理解： macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行） 每一个task会从头到尾将这个任务执行完毕，不会执行其它 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task-&gt;渲染-&gt;task-&gt;...） microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务 也就是说，在当前task任务后，下一个task之前，在渲染之前 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前） 分别很么样的场景会形成macrotask和microtask呢？ macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask） microtask：Promise，process.nextTick等 补充：在node环境下，process.nextTick的优先级高于Promise，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。 参考：https://segmentfault.com/q/1010000011914016 再根据线程来理解下： macrotask中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护 microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由JS引擎线程维护 （这点由自己理解+推测得出，因为它是在主线程下无缝执行的） 所以，总结下运行机制： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） 如图： 另外，请注意下Promise的polyfill与官方版本的区别： 官方版本中，是标准的microtask形式 polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式 请特别注意这两点区别 注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了），但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准） MutationObserver可以用来实现microtask（它属于microtask，优先级小于Promise，一般是Promise不支持时才会这样做） 它是HTML5中的新特性，作用是：监听一个DOM变动，当DOM对象树发生任何变动时，Mutation Observer会得到通知 像以前的Vue源码中就是利用它来模拟nextTick的，具体原理是，创建一个TextNode并监听内容变化，然后要nextTick的时候去改一下这个节点的文本内容，如下：（Vue的源码，未修改） var counter = 1 var observer = new MutationObserver(nextTickHandler) var textNode = document.createTextNode(String(counter)) observer.observe(textNode, { characterData: true }) timerFunc = () =&gt; { counter = (counter + 1) % 2 textNode.data = String(counter) }对应Vue源码链接 不过，现在的Vue（2.5+）的nextTick实现移除了MutationObserver的方式（据说是兼容性原因），取而代之的是使用MessageChannel（当然，默认情况仍然是Promise，不支持才兼容的）。 MessageChannel属于宏任务，优先级是：MessageChannel-&gt;setTimeout，所以Vue（2.5+）内部的nextTick与2.4及之前的实现是不一样的，需要注意下。 这里不展开，可以看下https://juejin.im/post/5a1af88f5188254a701ec230 写在最后的话看到这里，不知道对JS的运行机制是不是更加理解了，从头到尾梳理，而不是就某一个碎片化知识应该是会更清晰的吧？ 同时，也应该注意到了JS根本就没有想象的那么简单，前端的知识也是无穷无尽，层出不穷的概念、N多易忘的知识点、各式各样的框架、底层原理方面也是可以无限的往下深挖，然后你就会发现，你知道的太少了。。。 参考资料 https://www.cnblogs.com/lhb25/p/how-browsers-work.html https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/ https://segmentfault.com/p/1210000012780980 http://blog.csdn.net/u013510838/article/details/55211033 http://blog.csdn.net/Steward2011/article/details/51319298 http://www.imweb.io/topic/58e3bfa845e5c13468f567d5 https://segmentfault.com/a/1190000008015671 https://juejin.im/post/5a4ed917f265da3e317df515 http://www.cnblogs.com/iovec/p/7904416.html https://www.cnblogs.com/wyaocn/p/5761163.html http://www.ruanyifeng.com/blog/2014/10/event-loop.html#comment-text","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"js 运行机制","slug":"js-运行机制","permalink":"http://yoursite.com/tags/js-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"}]},{"title":"标签和分类管理","slug":"标签和分类管理","date":"2020-07-08T13:44:20.000Z","updated":"2020-07-20T03:09:43.699Z","comments":true,"path":"2020/07/08/标签和分类管理/","link":"","permalink":"http://yoursite.com/2020/07/08/%E6%A0%87%E7%AD%BE%E5%92%8C%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/","excerpt":"","text":"","categories":[],"tags":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"自动化构建工具","slug":"自动化构建工具","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"},{"name":"代码管理","slug":"代码管理","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"},{"name":"webpac","slug":"webpac","permalink":"http://yoursite.com/tags/webpac/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"工具（类库）","slug":"工具（类库）","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%EF%BC%88%E7%B1%BB%E5%BA%93%EF%BC%89/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"学习方向","slug":"学习方向","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%90%91/"},{"name":"学习规划","slug":"学习规划","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/"},{"name":"杂谈随笔","slug":"杂谈随笔","permalink":"http://yoursite.com/tags/%E6%9D%82%E8%B0%88%E9%9A%8F%E7%AC%94/"}]},{"title":"webpack","slug":"webpack学习","date":"2020-06-20T13:44:20.000Z","updated":"2020-07-19T15:32:54.377Z","comments":true,"path":"2020/06/20/webpack学习/","link":"","permalink":"http://yoursite.com/2020/06/20/webpack%E5%AD%A6%E4%B9%A0/","excerpt":"1、 简易模板","text":"1、 简易模板 ` const { resolve } = require(&apos;path&apos;); // node 的一个语法，引入路径模块中的 resolve const HtmlWebPackPlugin = require(&apos;html-webpack-plugin&apos;) // 引入下载好的插件 const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;) // 需要下载好插件，是用来把js中的样式提取到单独的文件 module.exports = { // 暴露出去 entry: &apos;.src.index.js&apos; // 入口文件，告诉 webpack 从哪里开始打包 output: { filename: &apos;build.js&apos;, // 输出文件，打包生成文件的文件名字 path: resolve(__dirname, &apos;build&apos;) // 生成文件的路径，__dirname表示当前目录，&apos;build&apos;表示这个文件下 }, module: { // 相当于写 loader 的地方，因为 webpack 只能识别 js 和 json ，所以需要loader把其他语言转换为认识的语言（相当于翻译官） relues: [ { test: /\\.less$/, // 正则所有 less后缀的文件 use: [ // 匹配的文件要使用哪些 loader &apos;style-loader&apos;, // 把 js 中的 样式创建 style 标签 &apos;css-loader&apos;, // 把 css 整合到 js 中 &apos;less-loader&apos; // 把 less 转换为 css ] }, { // 处理图片资源,两个包：url-loader 、 file-loader, // 问题: 这样 处理不了 html 文件中的img图片 test: /\\.(jpg|png|gif)$/, loader: &apos;url-loader&apos;, options: { // 图片大小少于 8kb， 就会转成 base64 // base64 优点： 减少请求数量（减轻服务器压力） // 缺点：图片体积会更大（请求速度慢） limit: 8 * 1024 // 假如出现问题： [Object Module] esModule: false } }, { test: /\\.html$/, // html-loader 专门处理 html 文件中 img 图片（负责引入这个图片，从而能被 url-loader进行处理） loader: &apos;html-loader&apos; } ] }, plugins: [ new HTMLWebpacPlugin({ // 这个插件会自动引入 打包后的文件，并生成空的html文件 template: &apos;./src/index.html&apos; // 把这个文件的 html结构 放到 生成的html 文件中 }) ], mode: &apos;development&apos;, // 开发服务器 devServer ，用来自动化（自动编译，自动打开浏览器，自动刷新） // 启动 devServer 指令：npx webpack-dev-server(需要下载这个包) 注意：全局安装的包 可以作为指令使用，局部安装的要使用 npx devServer: { contentBase: resolve(__dirname, &apos;build&apos;), // 运行项目的目录 compress: true, // 启动gzip压缩 port: 8080, // 指定端口号 open: true } }`","categories":[],"tags":[{"name":"自动化构建工具","slug":"自动化构建工具","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}]},{"title":"gulp","slug":"gulp学习","date":"2020-06-09T13:44:20.000Z","updated":"2020-07-20T03:09:46.477Z","comments":true,"path":"2020/06/09/gulp学习/","link":"","permalink":"http://yoursite.com/2020/06/09/gulp%E5%AD%A6%E4%B9%A0/","excerpt":"gulp 自动化构建工具学习gulp 是基于 node 的自动化构建工具（任务化和基于流，可同步或异步）","text":"gulp 自动化构建工具学习gulp 是基于 node 的自动化构建工具（任务化和基于流，可同步或异步） 一、安装 gulp1、安装 node2、全局安装 gulp // npm i -g gulp3、初始化 npm init 二、安装 gulp 常用插件三、新建 gulpfile.js 文件1、gulpfile.js 是 gulp 项目的配置文件。2、导入工具包 var gulp = require(‘gulp’) var less=require(‘gulp-less’);3、定义一个 less 任务，`gulp.task(‘testLess’,function(){ gulp.src(‘src/less/index.less’) // 指明是哪个文件接受任务 .pipe(less()) //该任务调用的模块，这里的 less 就是引进来的工具 .pipe(gulp.dest(‘src/css’)); //将会在 src/css 下生成 index.css })` 四、gulp 常用的插件var gulp = require(&#39;gulp&#39;) // 网页自动刷新（服务器控制客户端同步刷新）var livereload = require(&#39;gulp-livereload&#39;) // 本地服务器var webserver = require(&#39;gulp-webserver&#39;) // less 文件编译成 cssvar less = require(&#39;gulp-less&#39;) // 压缩 css 文件var cssmin =require(&#39;gulp-clean-css&#39;) // 生成 sourcemap 文件var sourcemaps = require(&#39;gulp-sourcemaps&#39;) // 当发生异常时提示错误var notify =require(&#39;gulp-notify&#39;)var plumber = require(&#39;gulp-plumber&#39;) // 压缩 html，可以压缩页面 javascript、css，去除页面空格、注释，删除多余属性等操作var htmlmin = require(&#39;gulp-htmlmin&#39;) // 只操作有过修改的文件var changed = require(&#39;gulp-changed&#39;) // 压缩图片文件（包括 PNG、JPEG、GIF 和 SVG 图片）var imagemin = require(&#39;gulp-imagemin&#39;) // 深度压缩图片var pngquant = require(&#39;imagemin-pngquant&#39;) //只压缩修改的图片，没有修改的图片直接从缓存文件读取var cache = require(&#39;gulp-cache&#39;) //给 css 文件里引用 url 加版本号var cssver = require(&#39;gulp-make-css-url-version&#39;) // 压缩 javascript 文件，减小文件大小var uglify =require(&#39;gulp-uglify&#39;) // 文件重命名var rename = require(&#39;gulp-rename&#39;) // 合并 javascript 文件，减少网络请求var concat = require(&#39;gulp-concat&#39;) // 文件清理 var clean = require(&#39;gulp-clean&#39;) 五、注意gulp 是可同步或者异步的，当方法下有 return 的时候，是异步的，任务回同时进行；相反则是同步的，任务会按顺序执行，时间也较长。","categories":[],"tags":[{"name":"自动化构建工具","slug":"自动化构建工具","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"}]}],"categories":[],"tags":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"js 运行机制","slug":"js-运行机制","permalink":"http://yoursite.com/tags/js-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"},{"name":"自动化构建工具","slug":"自动化构建工具","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"},{"name":"代码管理","slug":"代码管理","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"},{"name":"webpac","slug":"webpac","permalink":"http://yoursite.com/tags/webpac/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"工具（类库）","slug":"工具（类库）","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%EF%BC%88%E7%B1%BB%E5%BA%93%EF%BC%89/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"学习方向","slug":"学习方向","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%90%91/"},{"name":"学习规划","slug":"学习规划","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/"},{"name":"杂谈随笔","slug":"杂谈随笔","permalink":"http://yoursite.com/tags/%E6%9D%82%E8%B0%88%E9%9A%8F%E7%AC%94/"}]}